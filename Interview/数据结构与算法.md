## 数据结构与算法

**常见的降低算法复杂度的思路？**

这是在机试中需要反复思考的问题。很多问题都可以使用暴力方法求解，但获得的分数有限。

- 逆序对：归并排序、树状数组
- 二分搜索
- 线段树
- 字典树
- 模式匹配：KMP
- 矩阵快速幂、快速乘法

**找出一个数组中第二大的数？**

- 遍历数组，记录最大的数字和第二大的数字。
- 排序算法：归并排序、快速排序等。
- 优先级队列，获取第二大的数时，暂存最大的数。这比排序算法更快。

**动态规划和贪心有什么区别？**
二者解决的问题都满足最优子结构，即原问题的最优解可由子问题的最优解得到。
贪心算法还需要满足贪心选择性质，即整体最优解可以通过一系列局部最优的选择来达到。贪心选择只依赖于过去所做的选择，而不依赖于子问题的解。贪心算法通常自顶向下求解，而动态规划以自底向上的方式求解。对于具体问题使用贪心算法时，需要确定问题是否具有贪心选择性质。
常见的贪心算法包括 Dijkstra 算法、Prim 算法、Kruskal 算法。

**如何找出数组中异或后最大的两个数？**

- 暴力搜索
- 使用字典树表示数组中所有数的二进制：找到数组中最大的数m，从m的第一位不是0的数位开始，在字典树中查找和m对应数位相反的数。

**最小生成树算法的原理？**
常见的是两种贪心算法 Kruskal 算法和 Prim 算法。
- Kruskal 算法：不断寻找最短的边
  - 新建图G，G中拥有原图中相同的节点，但没有边
  - 将原图中所有的边按权值从小到大排序
  - 权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中
  - 重复3，直至图G中所有的节点都在同一个连通分量中
- Prim 算法：不断寻找最近的顶点

**KMP算法的原理？**

- 这个算法用于模式匹配。
- 在匹配过程中，即使失败，已经匹配的部分也可以加速下一次匹配，因此使用 lps 数组来存储对应子串的前缀和后缀相同的位数。
- 在匹配过程中，在每一次的逐个匹配完成后，无论完全匹配成功或中途失败，下一次匹配从 lps 记录的位置开始，减少了重复的匹配。
- 暴力法的时间复杂度是 $O(m*n)$，KMP 算法的时间复杂度是 $O(m + n)$.