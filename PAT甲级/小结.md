# PAT 甲级

## 1001 A + B

难点在于输出格式。

## 1002 多项式相加

注意遍历多项式数组时的边界，可能出现越界问题引发段错误。

多项式系数是小数，使用 `double` 存储，格式化输出一位小数。

## 1003 最短路问题

Dijkstra 算法可解，需要根据题意变形。

## 1004 统计叶结点数量

根据输入构建一棵多叉树，通过层次遍历统计叶结点数量。

## 1005 正确拼写

难点在于输出部分，可通过栈先获取数字高位。

注意输入的特殊情况，例如 `0`.

## 1006 登入登出

关键的两部分：格式化输入，时间戳大小判断。

## 1007 最大子序列和

线性动态规划。注意题目要求的两种输出情况。

## 1008 电梯

三种情况：上升、下降、停留。

## 1009 多项式相乘

指数相加，系数相乘。注意结果数组的大小应该是给定指数范围的 2 倍。

## 1010 进制转换

如果使用 `long long`，给定进制的数转换为十进制数时可能发生溢出。

## 1011 世界杯赌局

C语言基础题。

## 1014 队列等待

这是一道比较有难度的模拟题。注意点包括：
- 处理流程：首先填充黄线内的位置，然后处理黄线后的顾客请求
- 数据结构设计：需要维护窗口队列的弹出时间和整个窗口队列的结束时间。前者使黄线后的顾客能查找最早出现空位的窗口队列，后者用于计算顾客完成业务后的时间。
- 超时判断：如果计算出顾客接受服务的时间如果在 17:00 及之后，则顾客实际上无法在今天接受服务。注意这个时间是顾客开始接受服务的时间，而不是顾客接受服务结束的时间。

## 1015 反转素数

本题的要点是：
- 素数判定函数：小于等于 1 的数一定不是素数。
- 反转素数的判定：不能只判断转换后的数是否是素数，转换前的原十进制数也需要判定

## 1016 电话账单

本题的实现难点是：
- 输入数据中是乱序的，包括上线离线过程以及客户姓名都是乱序
- 如果一个客户的相关账单为空，不做输出
- 两时间之间作差

## 1020 树的遍历

由二叉树的后序遍历和中序遍历求层次遍历。

## 1021 最深的树根

- 图的深度优先遍历：设定 `vis` 数组，每次选定根进行全图 DFS 前重置 `vis` 数组。
- 连通分量数：使用并查集，没有路径压缩也未超时

## 1024 回文数

本题需要使用高精度数。题目没有指明 `k` 的下界，测试用例中有 `k = 0` 的情况。

## 1025 PAT 排名

排序需要的时间是 $O(n\log{n})$，计算全局排名和局部排名可以在 $O(n)$ 内完成。

## 1027 火星颜色

- 注意是**大写**字母表示 10 及以上的数字。
- 注意需要将各颜色的表示填充到 2 位字符。

## 1028 列表排序

根据情况，使用不同的排序方法。难度简单。

## 1029 中位数

本题对空间有严格限制，无法直接存储两个数组。
因为题目给定的两个序列都是有序的，本题解法是存储第一个数组，然后在读入第二个数组的每个元素时，判定比中位数小的数字是否已经都出现。

## 1030 旅游计划

最短路问题，使用 Dijkstra 加堆优化的算法可直接解。相比于 Dijkstra 模板题，本题的特殊性在于：
- 有路径距离和路径代价两种概念，实际上可按相同方法处理。
- 最短路径的输出，只需在执行松弛操作时记录当前路径的前一节点即可。

## 1031 U 型

计算出水平方向和垂直方向的两个长度即可。

## 1032 两链表的公共后缀

本题如果用 stl map 存储节点会在最后一个测试点超时。

本题只需要将第一个链表遍历，标记遍历到的节点，再遍历第二个链表。一旦遍历到此前出现过的节点，即为本题所求结果。链表节点中的数据与该求解思路无关。

实际上，不可能出现两链表交汇于同一节点又分叉的情况，这时两条链表是有歧义的。

## 1033 加油或不加油

本题的思路是贪心，难度较高。首先将所有加油站按距离排序，因为考虑远距离的加油站是有条件的，必须在近距离加油站加油到足够多的量，车辆才可能到达远距离的加油站。

两个变量对于加油与否的决策至关重要：

- 油箱容量
- 已经离开起点的距离

贪心策略：总是找到当前可达范围内最合适的一个加油站
- 如果可达范围内的加油站价格都比当前站的价格高，则选择可达范围内最低价格的加油站作为下一站
- 如果可达范围内存在加油站价格比当前站的价格低，选择第一个更低价格的加油站作为下一站

## 1034 帮派头目

本题考察并查集的运用，连通分量的遍历可以使用 DFS，也可以使用并查集直接完成。

- 如果出现运行时错误，是静态数组的大小不足。
- 输出的顺序是姓名的字典序。

## 1132 分割整数

除法需要避免除零，否则浮点错误。

## 1133 分割链表

使用 `cout` 很可能在最后一个测试点超时，应尝试使用 `printf`.

## 1136 延迟回文数

高精度整数的反转和高精度整数的相加。

样例中甚至没有去掉前导 0. 如果数字有前导 0 直接输出即可。

## 1137 期末成绩

细节问题：

- 没有记录的成绩记为 -1，初始化应该填充 -1.
- 期末成绩的计算规则，与平时成绩和期末成绩的大小关系相关
- 计算出期末成绩后，四舍五入，再做排序和输出

## 1138 后序遍历

二叉树十分经典的题目。给定二叉树的前序遍历和中序遍历，得到二叉树的后序遍历。

本题的要求更加简单，只需求后序遍历的第一个元素。

## 1139 首次联系

最后一个测试点数据量较大。本题可能需要使用 `printf` 而不是 `cout`。

STL 中的哈希表快于红黑树，PAT 在线测评支持 C++ 11. 

## 1140 读出序列

线性时间复杂度内遍历即可。

## 1141 PAT 学校排名

注意截断误差，计算分数时应使用 `double`，得到加权和后转换为 `int`，而不是直接使用 `int` 存储与计算。

## 1142 最大团问题

团与最大团是图论中的概念，这可能在一些离散数学课程中并没有介绍，题目对这一概念有简单的阐述。

团的概念相对容易理解。所谓最大团，即不能再找到一个结点与当前团中所有点相邻。但是，对于一个图，最大团不是唯一的。

## 1143 二叉搜索树的最近公共祖先

本题只给定了树的前序遍历，但这对于描述一颗树是不充分的，因此还需要充分利用二叉搜索树的性质。

- 方法1：通过二叉搜索树的性质和前序遍历建树，然后通过递归解法求最近公共祖先。
- 方法2：二叉搜索树中，两个结点的公共祖先的值一定在这两个结点的值之间。在前序遍历，一个结点的祖先一定先于该结点被遍历，因此两个结点的最近公共祖先一定 *恰好是* 或 *在前序遍历中先于* 两个结点中靠前的一个结点。另外，如何确定公共祖先中最近的一个？(todo) 实际上前序遍历数组中第一个值在两结点值之间的结点，就是两结点在二叉搜索树中的最近公共祖先。

## 1144 缺失的最小正整数

根据 150ms 时限，本题必须 $O(n)$.

使用 STL map 实现最暴力的方法可解。注意，输入数组中的数据范围在 `int`，无法申请到如此大的数组。

## 1145 散列-平均搜索时间

本题考查经典的散列算法，包括平方探测的概念。

通过数学证明可知，对于素数大小的散列表，平方探测在散列表中的轨迹是散列表大小的一半。

但本题计算平方探测的平均搜索次数时，对于每一次搜索最多的尝试次数是散列表大小加1？

## 1146 结点的拓扑排序判定

验证有向图的结点序列是否满足拓扑排序。只需要根据结点入度做判断。循环层数较多，注意变量不能写错。

## 1147 堆

本题分为两个部分：
- 大根堆/小根堆/不是堆的判定
- 二叉树层次遍历到后序遍历的转换

## 1148 狼人杀-简单版本

本题难点在题目描述不是十分直接，实际上两个说谎者中一定有一个是狼人、另外一个是人类。

本题的解决思路很简单，双层循环假设玩家中的狼人，并判断是否和玩家的描述相冲突。

## 1149 危险的货物打包

毫无算法技巧，也没有卡时间。直接暴力检查情况是否合法即可。相比 1148 题，题目更容易理解，是最送分的一道题。

## 1150 旅行商问题

首先注意到本题时间限制是 250ms，是相当严格的时限，但实际上没有算法上的难度。

旅行商问题是：找到从一点开始寻找遍历图中所有顶点，并回到原顶点的方案。

本题尝试求旅行商问题的近似解，容易失分的是三种路径情况的判断。一个合理的判断逻辑是：

- 该路径包含的顶点没有覆盖图，或该路径长度不足顶点数加1，或起点和终点不一致：不是 TS 环
- 该路径包含的顶点覆盖了图，路径长度恰好等于顶点数加1：TS 简单环
- 该路径包含的顶点覆盖了图，路径长度超过顶点数加1：TS 环

## 1151 二叉树的最近公共祖先

本题的核心算法是最近公共祖先，使用递归算法求解比较容易理解，可参考力扣 236. 二叉树的最近公共祖先。

另外，对树的处理可直接在两个遍历数组上进行，或使用链式结构建树。


## 1152 寻找质数

题目的背景十分震撼，如此考验数学似乎做不了啊。但这毕竟是一道 20 分的题目。

从字符串中提取小于 10 位的 `int` 型整数，判断是否为质数即可。

注意，如果有前导 0，应该输出前导 0. 这是一个得分点。

## 1153 PAT 记录查询

这道题在逻辑上没有难度，但非常容易超时。

一些加快程序速度的方法：
- `sync_with_stdio(false)` 和 `cin.tie(0)`
- 使用 `printf` 而不是 `cout`
- 对于第三种查询命令，使用 `map` 存储字符串出现的次数而不是线性遍历已有的记录。在遇到庞大的数据时 STL 并不总是很慢，`map` 是红黑树的实现，考场手写红黑树是不可能的

## 1154 顶点着色

本题首先容易想到种类并查集，同一类的顶点颜色必须不同？但实际上同一连通分量的顶点，并不满足颜色各不相同。考虑这样一种情况，相邻于根结点的两个结点不相邻，它们在同一连通分量中并且可以是同色的。

解决思路：对于每一种着色方案，通过遍历边判断着色是否合法即可。

## 1155 堆路径

本题考察堆的概念和堆的遍历，并没有涉及建堆、添加元素、删除元素、堆排序等相对复杂的算法。

本题再次说明，PAT 甲级着重考察的是基础数据结构，而不是深入考察算法。

假设存储树的数组索引从 1 开始，列出前 3 层结点的索引和树中的位置。

- 1：(1, 1)
- 2: (2, 1)
- 3: (2, 2)
- 4: (3, 1)
- 5: (3, 2)
- 6: (3, 3)
- 7: (3, 4)

其中的路径有，

- 1-3-7
- 1-3-6
- 1-2-5
- 1-2-4

可见，结点 `i` 的左子结点索引是 `2 * i`，右子结点的索引是 `2 * i + 1`.

使用 DFS 遍历所有路径即可，最后还需要输出最大堆/最小堆/不是堆的判定结果。