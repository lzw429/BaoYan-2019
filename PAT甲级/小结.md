# PAT 甲级

## 1001 A + B

难点在于输出格式。

## 1002 多项式相加

注意遍历多项式数组时的边界，可能出现越界问题引发段错误。

多项式系数是小数，使用 `double` 存储，格式化输出一位小数。

## 1003 最短路问题

Dijkstra 算法可解，需要根据题意变形。

## 1004 统计叶结点数量

根据输入构建一棵多叉树，通过层次遍历统计叶结点数量。

## 1005 正确拼写

难点在于输出部分，可通过栈先获取数字高位。

注意输入的特殊情况，例如 `0`.

## 1006 登入登出

关键的两部分：格式化输入，时间戳大小判断。

## 1007 最大子序列和

线性动态规划。注意题目要求的两种输出情况。

## 1008 电梯

三种情况：上升、下降、停留。

## 1009 多项式相乘

指数相加，系数相乘。注意结果数组的大小应该是给定指数范围的 2 倍。

## 1010 进制转换

如果使用 `long long`，给定进制的数转换为十进制数时可能发生溢出。

## 1011 世界杯赌局

C 语言基础题。

## 1014 队列等待

这是一道比较有难度的模拟题。注意点包括：
- 处理流程：首先填充黄线内的位置，然后处理黄线后的顾客请求
- 数据结构设计：需要维护窗口队列的弹出时间和整个窗口队列的结束时间。前者使黄线后的顾客能查找最早出现空位的窗口队列，后者用于计算顾客完成业务后的时间。
- 超时判断：如果计算出顾客接受服务的时间如果在 17:00 及之后，则顾客实际上无法在今天接受服务。注意这个时间是顾客开始接受服务的时间，而不是顾客接受服务结束的时间。

## 1015 反转素数

本题的要点是：
- 素数判定函数：小于等于 1 的数一定不是素数。
- 反转素数的判定：不能只判断转换后的数是否是素数，转换前的原十进制数也需要判定

## 1016 电话账单

本题的实现难点是：
- 输入数据中是乱序的，包括上线离线过程以及客户姓名都是乱序
- 如果一个客户的相关账单为空，不做输出
- 两时间之间作差

## 1020 树的遍历

由二叉树的后序遍历和中序遍历求层次遍历。

## 1021 最深的树根

- 图的深度优先遍历：设定 `vis` 数组，每次选定根进行全图 DFS 前重置 `vis` 数组。
- 连通分量数：使用并查集，没有路径压缩也未超时

## 1024 回文数

本题需要使用高精度数。题目没有指明 `k` 的下界，测试用例中有 `k = 0` 的情况。

## 1025 PAT 排名

排序需要的时间是 $O(n\log{n})$，计算全局排名和局部排名可以在 $O(n)$ 内完成。

## 1027 火星颜色

- 注意是**大写**字母表示 10 及以上的数字。
- 注意需要将各颜色的表示填充到 2 位字符。

## 1028 列表排序

根据情况，使用不同的排序方法。难度简单。

## 1029 中位数

本题对空间有严格限制，无法直接存储两个数组。
因为题目给定的两个序列都是有序的，本题解法是存储第一个数组，然后在读入第二个数组的每个元素时，判定比中位数小的数字是否已经都出现。

## 1030 旅游计划

最短路问题，使用 Dijkstra 加堆优化的算法可直接解。相比于 Dijkstra 模板题，本题的特殊性在于：
- 有路径距离和路径代价两种概念，实际上可按相同方法处理。
- 最短路径的输出，只需在执行松弛操作时记录当前路径的前一节点即可。

## 1031 U 型

计算出水平方向和垂直方向的两个长度即可。

## 1032 两链表的公共后缀

本题如果用 stl map 存储节点会在最后一个测试点超时。

本题只需要将第一个链表遍历，标记遍历到的节点，再遍历第二个链表。一旦遍历到此前出现过的节点，即为本题所求结果。链表节点中的数据与该求解思路无关。

实际上，不可能出现两链表交汇于同一节点又分叉的情况，这时两条链表是有歧义的。

## 1033 加油或不加油

本题的思路是贪心，难度较高。首先将所有加油站按距离排序，因为考虑远距离的加油站是有条件的，必须在近距离加油站加油到足够多的量，车辆才可能到达远距离的加油站。

两个变量对于加油与否的决策至关重要：

- 油箱容量
- 已经离开起点的距离

贪心策略：总是找到当前可达范围内最合适的一个加油站
- 如果可达范围内的加油站价格都比当前站的价格高，则选择可达范围内最低价格的加油站作为下一站
- 如果可达范围内存在加油站价格比当前站的价格低，选择第一个更低价格的加油站作为下一站

## 1034 帮派头目

本题考察并查集的运用，连通分量的遍历可以使用 DFS，也可以使用并查集直接完成。

- 如果出现运行时错误，是静态数组的大小不足。
- 输出的顺序是姓名的字典序。

## 1099 构建二叉搜索树

逻辑越简单的题目，对格式的要求越强。

## 1102 反转二叉树

由于按行输入，而不是链式存储的树，反转二叉树并不是难点。本题重点在于层次遍历和中序遍历的实现。

## 1108 找平均数

使用 `sscanf` 和 `sprintf` 可方便地判断，输入的字符串是否是合法的两位以内的小数。

一定要仔细阅读题目给出的输入输出规范，能复制就不手打，例如本题中的这个细节：
`0 numbers` `1 number` `K numbers` 

## 1112 卡住的键盘

一个字母，必须在每次出现时都出现 k 的倍数次，才可能是被卡住的键。因为一个字母可能在字符串中出现多次，有时是出现了 k 的次数，而有时不是，这时不能认定它是被卡住的键。

需要注意的是，需要按字母在字符串中出现的最早位置来输出被卡住的字符。

## 1114 家族财产

本题考察并查集的使用。将一个家庭中的成员使用图中的一个连通分量表示，在合并两结点时，总是将编号较大的结点合并到编号较小的结点，便于最终结果的比较。

可行的解法是建立家族成员最小编号到家庭财产信息的映射 map，在需要排序时将 map 中的元素添加到 vector 中。

数字范围是 0000～9999.

## 1115 二叉搜索树的结点计数

仔细阅读题目，左子树是小于等于，右子树是大于。

## 1116 比赛发奖品

难度十分简单。

## 1117 爱丁顿数

注意仔细阅读「爱丁顿数」的英文定义，必须是大于而不是大于等于。

从大到小检验，而不是从小到大检验可避免超时。

## 1118 树林中的鸟

本题考察并查集。使用输入优化可以勉强在时限内，使用并查集查询的路径压缩可以大幅降低运行时间。

## 1119 前序和后序遍历

阅读到本题，给人的感觉是「数据结构」课程一道有一定难度课后习题。

首先需要明白为什么前序遍历和后序遍历无法确定一棵唯一的二叉树。因为前序遍历和后序遍历，都无法确定根结点的子结点是左子结点还是右子结点。

本题中可以首先假定根结点存在的子树是右子树，如果推断出左子树也一定存在，则答案应是唯一的；如果左子树不一定存在，实际上子树的左右无法确定，答案不唯一。

## 1120 友数

难度十分简单。

## 1121 单身狗

难度十分简单。

注意，每个人的编号由 5 位整数表示；输出时，如果数字不足 5 位必须填充前导 0，这是一个给分点。

## 1122 哈密顿回路判定

哈密顿回路的定义是：包含图中所有顶点的简单回路。

对于一条顶点组成的序列，只需要判断：

- 是否覆盖图中所有顶点
- 序列的长度是否等于顶点数加1
- 序列中相邻两个顶点在图中是否是相邻的
- 起点和终点是否一致

## 1123 完全 AVL 树判定

本题需要直接实现 AVL 树的插入算法，并包含完全二叉树的判定问题。

完全二叉树在层次遍历中的判定是，如果遇到某结点的子结点是 NULL，则设置 afterNull 为 true；当 afterNull 设置为 true 后，如果还有结点的子结点不是 NULL，说明至少存在一层结点的中间有空结点，使得该树不是完全二叉树。

AVL 树的实现值得反复练习。

## 1124 微博听众抽奖

注意如果某听众已经被抽到过，尝试向后顺延一位。

## 1125 链接绳索

实质上是哈夫曼树问题。`priority_queue` 默认是大根堆，需要手动添加小根堆所需参数。

## 1126 欧拉路径

本题讨论无向图中的欧拉路。

- 欧拉图：无向连通图中，所有顶点的度为偶数。
- 半欧拉路：无向连通图中，恰好两个顶点的度为奇数，其他顶点的度为偶数。
- 非欧拉图：非连通图，或连通图中的顶点度数不符合要求。

## 1127 二叉树的锯齿形遍历

LeetCode 原题，是对层次遍历的变形。至少有两种方法：

- 在常规的层次遍历基础上，对每一层遍历的结果暂存，在奇数层对该层结果翻转，偶数层不对该层结果翻转。
- 在常规的层次遍历基础上，在奇数层对存储树结点对队列进行翻转，偶数层不翻转。

两种方法的特点都是，奇数层翻转，偶数层不翻转。

## 1128 N 皇后问题

本题不是解 N 皇后问题，而只是简单地判定。题目的文字描述和图片可能让人感到疑惑，因为图片中并没有标行号和列号，实际上图片是被旋转过的。

只需要判断任意两个皇后是否在同一行、同一对角线、同一副对角线上即可。

## 1129 推荐系统

题意为，数字首先按出现次数排序，然后按数字大小排序。

本题如果使用 `vector` 存储已遍历过的数字可能超时；如果使用 `map`，对值排序可能是繁琐的。

一种简单的方法是使用 `set<Node>`，`set` 由红黑树实现，可实现有序遍历，在 `Node` 结构体中需要自定义比较函数，其成员变量包含数值和该数值的出现次数。

## 1130 中缀表达式

给定一棵二叉的语法树，输出对应的中缀表达式。对于树的叶结点和根结点中的数据，不输出括号；对于树的中间结点的数据，输出括号。

算法过程即简单地中序遍历二叉语法树。

## 1131 地铁图

地铁线路可能是环线，每个点不可能有自环。一个地铁站可能是中转站，同时属于不超过5条的地铁线路。

本题的实现细节较为复杂，值得反复练习。

## 1132 分割整数

除法需要避免除零，否则浮点错误。

## 1133 分割链表

使用 `cout` 很可能在最后一个测试点超时，应尝试使用 `printf`.

## 1134 顶点覆盖

图的覆盖是一些顶点（或边）的集合，使得图中的每一条边（每一个顶点）都至少接触集合中的一个顶点（边）。

读写非常耗时，建议关闭标准输入输出读写同步以提升读写效率。

## 1135 红黑树判定

刚看题目以为要手写红黑树，但其实只是简单的判定。

红黑树是一种平衡的二叉搜索树，可以通过 4 阶 B 树理解，它满足以下 5 条性质：

- 每个结点是红色的，或者黑色的。
- 根结点是黑色的。
- 叶结点（NULL）是黑色的。
- 红结点的子结点都是黑结点。即红结点的父结点和子结点都是黑结点。
- 每个结点到叶结点的所有路径中，黑结点的数目相同。

首先根据平衡二叉搜索树的前序遍历，建立一棵红黑树，然后关于这五条规则，程序中主要进行三项判断：

1. 根结点是否是黑色
2. 树中所有红色结点，如果有子结点，是否一定是黑结点
3. 树中所有路径的黑结点数量是否都相同

(1) 的判断非常容易，(2)(3) 建议使用递归方法实现。

本题不存在大数据超时问题。

## 1136 延迟回文数

高精度整数的反转和高精度整数的相加。

样例中甚至没有去掉前导 0. 如果数字有前导 0 直接输出即可。

## 1137 期末成绩

细节问题：

- 没有记录的成绩记为 -1，初始化应该填充 -1.
- 期末成绩的计算规则，与平时成绩和期末成绩的大小关系相关
- 计算出期末成绩后，四舍五入，再做排序和输出

## 1138 后序遍历

二叉树十分经典的题目。给定二叉树的前序遍历和中序遍历，得到二叉树的后序遍历。

本题的要求更加简单，只需求后序遍历的第一个元素。

## 1139 首次联系

最后一个测试点数据量较大。本题可能需要使用 `printf` 而不是 `cout`。

STL 中的哈希表快于红黑树，PAT 在线测评支持 C++ 11. 

## 1140 读出序列

线性时间复杂度内遍历即可。

## 1141 PAT 学校排名

注意截断误差，计算分数时应使用 `double`，得到加权和后转换为 `int`，而不是直接使用 `int` 存储与计算。

## 1142 最大团问题

团与最大团是图论中的概念，这可能在一些离散数学课程中并没有介绍，题目对这一概念有简单的阐述。

团的概念相对容易理解。所谓最大团，即不能再找到一个结点与当前团中所有点相邻。但是，对于一个图，最大团不是唯一的。

## 1143 二叉搜索树的最近公共祖先

本题只给定了树的前序遍历，但这对于描述一颗树是不充分的，因此还需要充分利用二叉搜索树的性质。

- 方法1：通过二叉搜索树的性质和前序遍历建树，然后通过递归解法求最近公共祖先。
- 方法2：二叉搜索树中，两个结点的公共祖先的值一定在这两个结点的值之间。在前序遍历，一个结点的祖先一定先于该结点被遍历，因此两个结点的最近公共祖先一定 *恰好是* 或 *在前序遍历中先于* 两个结点中靠前的一个结点。另外，如何确定公共祖先中最近的一个？(todo) 实际上前序遍历数组中第一个值在两结点值之间的结点，就是两结点在二叉搜索树中的最近公共祖先。

## 1144 缺失的最小正整数

根据 150ms 时限，本题必须 $O(n)$.

使用 STL map 实现最暴力的方法可解。注意，输入数组中的数据范围在 `int`，无法申请到如此大的数组。

## 1145 散列-平均搜索时间

本题考查经典的散列算法，包括平方探测的概念。

通过数学证明可知，对于素数大小的散列表，平方探测在散列表中的轨迹是散列表大小的一半。

但本题计算平方探测的平均搜索次数时，对于每一次搜索最多的尝试次数是散列表大小加1？

## 1146 结点的拓扑排序判定

验证有向图的结点序列是否满足拓扑排序。只需要根据结点入度做判断。循环层数较多，注意变量不能写错。

## 1147 堆

本题分为两个部分：
- 大根堆/小根堆/不是堆的判定
- 二叉树层次遍历到后序遍历的转换

## 1148 狼人杀-简单版本

本题难点在题目描述不是十分直接，实际上两个说谎者中一定有一个是狼人、另外一个是人类。

本题的解决思路很简单，双层循环假设玩家中的狼人，并判断是否和玩家的描述相冲突。

## 1149 危险的货物打包

毫无算法技巧，也没有卡时间。直接暴力检查情况是否合法即可。相比 1148 题，题目更容易理解，是最送分的一道题。

## 1150 旅行商问题

首先注意到本题时间限制是 250ms，是相当严格的时限，但实际上没有算法上的难度。

旅行商问题是：找到从一点开始寻找遍历图中所有顶点，并回到原顶点的方案。

本题尝试求旅行商问题的近似解，容易失分的是三种路径情况的判断。一个合理的判断逻辑是：

- 该路径包含的顶点没有覆盖图，或该路径长度不足顶点数加1，或起点和终点不一致：不是 TS 环
- 该路径包含的顶点覆盖了图，路径长度恰好等于顶点数加1：TS 简单环
- 该路径包含的顶点覆盖了图，路径长度超过顶点数加1：TS 环

## 1151 二叉树的最近公共祖先

本题的核心算法是最近公共祖先，使用递归算法求解比较容易理解，可参考力扣 236. 二叉树的最近公共祖先。

另外，对树的处理可直接在两个遍历数组上进行，或使用链式结构建树。


## 1152 寻找质数

题目的背景十分震撼，如此考验数学似乎做不了啊。但这毕竟是一道 20 分的题目。

从字符串中提取小于 10 位的 `int` 型整数，判断是否为质数即可。

注意，如果有前导 0，应该输出前导 0. 这是一个得分点。

## 1153 PAT 记录查询

这道题在逻辑上没有难度，但非常容易超时。

一些加快程序速度的方法：
- `sync_with_stdio(false)` 和 `cin.tie(0)`
- 使用 `printf` 而不是 `cout`
- 对于第三种查询命令，使用 `map` 存储字符串出现的次数而不是线性遍历已有的记录。在遇到庞大的数据时 STL 并不总是很慢，`map` 是红黑树的实现，考场手写红黑树是不可能的

## 1154 顶点着色

本题首先容易想到种类并查集，同一类的顶点颜色必须不同？但实际上同一连通分量的顶点，并不满足颜色各不相同。考虑这样一种情况，相邻于根结点的两个结点不相邻，它们在同一连通分量中并且可以是同色的。

解决思路：对于每一种着色方案，通过遍历边判断着色是否合法即可。

## 1155 堆路径

本题考察堆的概念和堆的遍历，并没有涉及建堆、添加元素、删除元素、堆排序等相对复杂的算法。

本题再次说明，PAT 甲级着重考察的是基础数据结构，而不是深入考察算法。

假设存储树的数组索引从 1 开始，列出前 3 层结点的索引和树中的位置。

- 1：(1, 1)
- 2: (2, 1)
- 3: (2, 2)
- 4: (3, 1)
- 5: (3, 2)
- 6: (3, 3)
- 7: (3, 4)

其中的路径有，

- 1-3-7
- 1-3-6
- 1-2-5
- 1-2-4

可见，结点 `i` 的左子结点索引是 `2 * i`，右子结点的索引是 `2 * i + 1`.

使用 DFS 遍历所有路径即可，最后还需要输出最大堆/最小堆/不是堆的判定结果。