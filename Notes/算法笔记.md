# 保研机试代码手册

本文用以记录《算法手册》、《王道论坛计算机考研机试指南》中讲解的重要代码，以及来自于 POJ、百练 OJ、LeetCode 等平台的重要题目。

在这段旅程中，请记住：

> 遗忘最大的敌人是重复。

## 第1章 入门模拟

### 1.1 简单模拟

### 1.2 查找元素

### 1.3 图形输出

本题型为**蓝桥杯省赛**改错题。

### 1.4 日期处理

本题型为**蓝桥杯省赛**选择题。

#### 1.4.1 计算日期差

- **王道例 2.3** 输入两日期，计算差值。

注意题目要求，连续的两个日期，它们之间的天数是1天还是2天？第二个日期是否一定比第一个日期大？

```C++
#include <iostream>
#define ISYEAP(x) ((x % 4 == 0 && x % 100 != 0) || x % 400 ==0) ? 1 : 0
using namespace std;

int buf[5001][13][32]; // 存储相对日期
int dayOfMonth[13][2] = {0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31}; // 平年和闰年的每月天数

struct Date{
    int day;
    int month;
    int year;
    void nextDay(){
        day++;
        if(day > dayOfMonth[month][ISYEAP(year)]){
            day = 1;
            month++;
            if(month > 12){
                month = 1;
                year++;
            }
        }
    }
};

int main()
{
    Date date;
    int cnt = 0;
    date.day = date.month = 1;
    date.year = 0;
    while(date.year != 5001){
        buf[date.year][date.month][date.day] = cnt;
        date.nextDay();
        cnt++;
    }
    int y1, y2, m1, m2, d1, d2;
    while(scanf("%4d%2d%2d", &y1, &m1, &d1) != EOF){
        scanf("%4d%2d%2d", &y2, &m2, &d2);
        cout << abs(buf[y2][m2][d2] - buf[y1][m1][d1]) + 1 << endl;
    }
    return 0;
}
```



#### 1.4.2 计算星期几

- **王道例 2.4** 输入年月日，计算星期几。

根据 Windows 时间功能，可知今天是星期几，然后进行推算。

```C++
/*
样例输入：
9 October 2001
14 October 2001

样例输出：
Tuesday
Sunday
*/

#include <iostream>
#include <cstring>
#define ISYEAP(x) (x % 4 == 0 && x % 100 != 0 || x % 400 == 0) ? 1 : 0

using namespace std;

int buf[5001][13][32]; // 相对日期 

// 相比于将转换完全写在函数中，打表是更好的实现方式 
int dayOfMonth[13][2] = {0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31}; // 平年和闰年的每月天数 
char weekName[7][20] = {"Sunday",   "Monday", "Tuesday", "Wednesday",
                        "Thursday", "Friday", "Saturday"};
char monthName[12][20] = {"January",   "February", "March",    "April",
                          "May",       "June",     "July",     "August",
                          "September", "October",  "November", "December"};  // 请记住这些单词 

struct Date
{
	int year;
	int month;
	int day;
	void nextDay() {
		day++;
		if(day > dayOfMonth[month][ISYEAP(year)]) {
			day = 1;
			month++;
			if(month > 12) {
				month = 1;
				year++;
			}
		} 
	}
};

int main() {
	int day, year, m;
	int cnt = 0; // 计算天数差
	char month[20]; // 字符数组末尾有'\0' 
	
	Date date;
	date.year = 0;
	date.month = date.day = 1;

	while(date.year < 5001) {
		buf[date.year][date.month][date.day] = cnt;
		date.nextDay();
		cnt++;
	}
	
	while(cin >> day >> month >> year) {
		for(int i = 0; i < 12 ; i++) {
			if(strcmp(month, monthName[i]) == 0) {
				m = i + 1;
				break;
			}
		}
		// 2019 年 2 月 24 日 星期日 
		int timeDiff = buf[year][m][day] - buf[2019][2][24]; // 时间差可正可负
		cout << weekName[(timeDiff % 7 + 7) % 7] << endl;
	}
	return 0;
}
```

小结：

- 星期和月份的英文单词需牢记。
- 字符数组末尾有 `\0`，输入长度有限的字符串时优先考虑字符数组。
- 时间差可正可负，进行模运算前需处理。



### 1.5 进制转换

### 1.6 字符串处理



## 第2章 算法初步

### 2.1 排序

#### 2.1.1 冒泡排序

时间复杂度：$O(n^2)$
空间复杂度：$O(1)​$

```C++
// 对 a[0] ~ a[n] 进行排序
void bubbleSort(){
    for (int i = 0; i < n; i++) { // 循环次数比数组长度小 1
        for (int j = 0; j < n - i - 1; j++) {
			if (a[j] > a[j + 1]) { // 交换 a[j] 与 a[j+1]
				int t = a[j];
                a[j] = a[j + 1];
                a[j + 1] = t;
			}
        }
    }
}
```



#### 2.1.2 选择排序

时间复杂度：$O(n^2)$
空间复杂度：$O(1)​$

```C++
// 对 a[0] ~ a[n] 进行排序
void selectSort(){
    for(int i = 0; i < n; i++){ // 循环次数比数组长度小 1
        int k = i;
        for(int j = i; j <= n; j++){
            if(a[j] < a[k]) // 选出未排序区间中最小的元素，下标为 k
                k = j;
        }
        int temp = a[i]; // 交换 A[i] 与 A[k]
        a[i] = a[k];
        a[k] = temp;
    }
}
```



#### 2.1.3 插入排序

#### 2.1.4 双指针：归并排序

#### 2.1.5 双指针：快速排序

#### 2.1.6 排序与 sort 函数的应用



## 第3章 数学问题

### 3.1 简单数学



### 3.2 最大公约数与最小公倍数

#### 3.2.1 最大公约数：欧几里得算法 / 辗转相除法

- 非递归实现

```C++
int GCD(int a, int b){
    if(b)
        while((a %= b) && (b %= a));
    return a + b;
}
```

```C++
int GCD(int a, int b){
    while(b){
        int t = a % b;
        b = a;
        a = t;
    }
    return a;
}
```

- 递归实现

```C++
int GCD(int a, int b){
    return b ? GCD(b, a % b) : a;
}
```



#### 3.2.2 最小公倍数

```C++
int LCM(int a, int b){
    return a / GCD(a, b) * b; // 先除后乘避免溢出
}
```



### 3.3 分数四则运算

#### 3.3.1 分数表示与化简

- 分数的表示
  - 常用假分数的形式表示
  - 设分母为非负数；如果分数为负，令分子为负即可
  - 分子和分母没有除了1以外的公约数，即总是约分

```C++
struct Fraction { // 分数
    int up, down; // 分子，分母
}
```

- 分数的化简
  - 如果分母为负数，分子、分母都取相反数
  - 如果分子为0，令分母为1
  - 约分：求出分子**绝对值**与分母**绝对值**的最大公约数`d`，令分子分母同时除以`d`

```C++
Fraction reduction(Fraction result){
    if(result.down < 0){
        result.down = -result.down;
        result.up = -result.up;
    }
    if(result.up == 0)
        result.down = 1;
    else{
        int d = GCD(abs(result.up), abs(result.down));
        result.up /= d;
        result.down /= d;
    }
    return result;
}
```

#### 3.3.2 分数四则运算

- 分数的加法

```C++
Fraction add(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.down + f2.up * f1.down;
    result.down = f1.down * f2.down;
    return reduction(result);
}
```

- 分数的减法

```C++
Fraction minu(Fraction f){
    f.up = -f.up;
    return reduction(f);
}

Fraction minu(Fraction f1, Fraction f2){
    return add(f1, minu(f2));
}
```

- 分数的乘法

```C++
Fraction multi(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.up;
    result.down = f1.down * f2.down;
    return reduction(result);
}
```

- 分数的除法

```C++
Fraction divide(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.down;
    result.down = f1.down * f2.up;
    return reduction(result);
}
```



#### 3.3.3 分数的输出

- 输出分数前，进行**化简**。
- 如果分母为1，则该分数为**整数**，直接输出分子。
- 如果分子绝对值大于分母，则该分数为假分数，应以**带分数**的形式输出。
- 若以上均不满足，则分数是**真分数**，按原样输出即可。

```C++
void showResult(Fraction r) {
    r = reduction(r);
    if(r.down == 1) printf("%lld", r.up); // 整数
    else if(abs(r.up) > r.down) { // 假分数
        printf("%d %d/%d", r.up / r.down, abs(r.up) % r.down, r.down);
    }
    else {
        printf("%d/%d", r.up, r.down);
    }
}
```



### 3.4 素数

#### 3.4.1 素数的判断

素数判断，若 $n​$ 为素数返回`true`，非素数返回`false`。

- 注意，小于等于1的整数非素数。
- 只需要循环判断小于等于 $\sqrt{n}$ 的整数是否为 $n$ 的因子。

```C++
bool isPrime(int n) {
    if(n <= 1) return false;
    for(int i = 2; i * i <= n; i++) { // 或 i <= (int)sqrt(n + 0.5)
        if(n % i == 0) return false;
    }
    return true;
}
```



#### 3.4.2 素数表的获取

构建素数表 `comp`，`comp[i]`为假表示`i`为素数，`comp[i]`为真表示`i`为合数。

```C++
int m = sqrt(n + 0.5);
bool comp[n + 5];
memset(comp, false, sizeof(comp));

for(int i = 2; i <= m; i++) {
    if(!comp[i]) {
        for(int j = i * i; j <= n; j += i) {
            comp[j] = true;
        }
    }
}
```



## 第4章 C++ 标准模版库

## 第5章 数据结构：栈、队列与链表

## 第6章 搜索

### 6.1 枚举

### 6.2 广度优先搜索 BFS

### 6.3 递归

### 6.4 深度优先搜索 DFS

## 第7章 树算法

## 第8章 图算法

### 8.1 图的存储

图的表示形式通常是邻接矩阵或邻接表。

- 邻接表表示图

```C++
struct Node {
    int v; // 边的终点编号
    int w; // 边权
    Node(int v, int w): v(v), w(w) {} // 构造函数
}
vector<Node> adj[N];
```

### 8.2 图的遍历

#### 8.2.1 图的深度优先遍历

#### 8.2.2 图的广度优先遍历



### 8.3 最短路径



## 第9章 动态规划

## 第10章 字符串

## 第11章 专题扩展

### 11.1 分块思想

### 11.2 树状数组

#### 

#### 