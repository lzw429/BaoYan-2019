# 保研机试代码手册

本文用以记录《算法手册》、《王道论坛计算机考研机试指南》中讲解的重要代码，以及来自于 POJ、百练 OJ、LeetCode 等平台的重要题目。

在这段旅程中，请记住：

> 遗忘最大的敌人是重复。

## 第1章 入门模拟

### 1.1 简单模拟

### 1.2 查找元素

### 1.3 图形输出

本题型为**蓝桥杯省赛**改错题。

### 1.4 日期处理

本题型为**蓝桥杯省赛**选择题。

#### 1.4.1 计算日期差

- **王道例 2.3** 输入两日期，计算差值。

注意题目要求，连续的两个日期，它们之间的天数是1天还是2天？第二个日期是否一定比第一个日期大？

```C++
#include <iostream>
#define ISYEAP(x) ((x % 4 == 0 && x % 100 != 0) || x % 400 ==0) ? 1 : 0
using namespace std;

int buf[5001][13][32]; // 存储相对日期
int dayOfMonth[13][2] = {0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31}; // 平年和闰年的每月天数

struct Date{
    int day;
    int month;
    int year;
    void nextDay(){
        day++;
        if(day > dayOfMonth[month][ISYEAP(year)]){
            day = 1;
            month++;
            if(month > 12){
                month = 1;
                year++;
            }
        }
    }
};

int main()
{
    Date date;
    int cnt = 0;
    date.day = date.month = 1;
    date.year = 0;
    while(date.year != 5001){
        buf[date.year][date.month][date.day] = cnt;
        date.nextDay();
        cnt++;
    }
    int y1, y2, m1, m2, d1, d2;
    while(scanf("%4d%2d%2d", &y1, &m1, &d1) != EOF){
        scanf("%4d%2d%2d", &y2, &m2, &d2);
        cout << abs(buf[y2][m2][d2] - buf[y1][m1][d1]) + 1 << endl;
    }
    return 0;
}
```



#### 1.4.2 计算星期几

- **王道例 2.4** 输入年月日，计算星期几。

根据 Windows 时间功能，可知今天是星期几，然后进行推算。

```C++

```





### 1.5 进制转换

### 1.6 字符串处理



## 第2章 算法初步

### 2.1 排序

#### 2.1.1 冒泡排序

时间复杂度：$O(n^2)$
空间复杂度：$O(1)​$

```C++
// 对 a[0] ~ a[n] 进行排序
void bubbleSort(){
    for (int i = 0; i < n; i++) { // 循环次数比数组长度小 1
        for (int j = 0; j < n - i - 1; j++) {
			if (a[j] > a[j + 1]) { // 交换 a[j] 与 a[j+1]
				int t = a[j];
                a[j] = a[j + 1];
                a[j + 1] = t;
			}
        }
    }
}
```



#### 2.1.2 选择排序

时间复杂度：$O(n^2)$
空间复杂度：$O(1)​$

```C++
// 对 a[0] ~ a[n] 进行排序
void selectSort(){
    for(int i = 0; i < n; i++){ // 循环次数比数组长度小 1
        int k = i;
        for(int j = i; j <= n; j++){
            if(a[j] < a[k]) // 选出未排序区间中最小的元素，下标为 k
                k = j;
        }
        int temp = a[i]; // 交换 A[i] 与 A[k]
        a[i] = a[k];
        a[k] = temp;
    }
}
```



#### 2.1.3 插入排序

#### 2.1.4 双指针：归并排序

#### 2.1.5 双指针：快速排序



## 学习计划 todo

#### C++ sort 函数的使用

### 4 数学类

#### 进制转换

#### 最大公约数与最小公倍数

#### 素数

#### 快速幂

### 5 图论

#### 5.1 最短路问题

##### 5.1.1 Dijkstra 算法

##### 5.1.2 Floyd 算法

#### 5.2 最小生成树

Kruskal 算法

Prim 算法

#### 5.3 拓扑排序

#### 6 搜索

#### 6.1 枚举

#### 6.2 广度优先搜索 BFS

#### 6.3 递归

#### 6.4 深度优先搜索 DFS

### 7 动态规划

#### 7.1 递归求解

#### 7.2 最长递增子序列 LIS

#### 7.3 最长公共子序列 LCS

#### 7.4 状态与状态转移方程

### 8 其他技巧

#### 8.1 标准模版库 STL