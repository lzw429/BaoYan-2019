# 保研机试代码手册

本文用以记录《算法手册》、《王道论坛计算机考研机试指南》中讲解的重要代码，以及来自于 POJ、百练 OJ、LeetCode 等平台的重要题目。

在这段旅程中，请记住：

> 遗忘最大的敌人是重复。

## 第1章 入门模拟

### 1.1 简单模拟

### 1.2 查找元素

### 1.3 图形输出

本题型为**蓝桥杯省赛**改错题。

### 1.4 日期处理

本题型为**蓝桥杯省赛**选择题。

#### 1.4.1 计算日期差

- **王道例 2.3** 输入两日期，计算差值。

注意题目要求，连续的两个日期，它们之间的天数是1天还是2天？第二个日期是否一定比第一个日期大？

```C++
#include <iostream>
#define ISYEAP(x) ((x % 4 == 0 && x % 100 != 0) || x % 400 ==0) ? 1 : 0
using namespace std;

int buf[5001][13][32]; // 存储相对日期
int dayOfMonth[13][2] = {0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31}; // 平年和闰年的每月天数

struct Date{
    int day;
    int month;
    int year;
    void nextDay(){
        day++;
        if(day > dayOfMonth[month][ISYEAP(year)]){
            day = 1;
            month++;
            if(month > 12){
                month = 1;
                year++;
            }
        }
    }
};

int main()
{
    Date date;
    int cnt = 0;
    date.day = date.month = 1;
    date.year = 0;
    while(date.year != 5001){
        buf[date.year][date.month][date.day] = cnt;
        date.nextDay();
        cnt++;
    }
    int y1, y2, m1, m2, d1, d2;
    while(scanf("%4d%2d%2d", &y1, &m1, &d1) != EOF){
        scanf("%4d%2d%2d", &y2, &m2, &d2);
        cout << abs(buf[y2][m2][d2] - buf[y1][m1][d1]) + 1 << endl;
    }
    return 0;
}
```



#### 1.4.2 计算星期几

- **王道例 2.4** 输入年月日，计算星期几。

根据 Windows 时间功能，可知今天是星期几，然后进行推算。

```C++
/*
样例输入：
9 October 2001
14 October 2001

样例输出：
Tuesday
Sunday
*/

#include <iostream>
#include <cstring>
#define ISYEAP(x) (x % 4 == 0 && x % 100 != 0 || x % 400 == 0) ? 1 : 0

using namespace std;

int buf[5001][13][32]; // 相对日期 

// 相比于将转换完全写在函数中，打表是更好的实现方式 
int dayOfMonth[13][2] = {0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31}; // 平年和闰年的每月天数 
char weekName[7][20] = {"Sunday",   "Monday", "Tuesday", "Wednesday",
                        "Thursday", "Friday", "Saturday"};
char monthName[12][20] = {"January",   "February", "March",    "April",
                          "May",       "June",     "July",     "August",
                          "September", "October",  "November", "December"};  // 请记住这些单词 

struct Date
{
	int year;
	int month;
	int day;
	void nextDay() {
		day++;
		if(day > dayOfMonth[month][ISYEAP(year)]) {
			day = 1;
			month++;
			if(month > 12) {
				month = 1;
				year++;
			}
		} 
	}
};

int main() {
	int day, year, m;
	int cnt = 0; // 计算天数差
	char month[20]; // 字符数组末尾有'\0' 
	
	Date date;
	date.year = 0;
	date.month = date.day = 1;

	while(date.year < 5001) {
		buf[date.year][date.month][date.day] = cnt;
		date.nextDay();
		cnt++;
	}
	
	while(cin >> day >> month >> year) {
		for(int i = 0; i < 12 ; i++) {
			if(strcmp(month, monthName[i]) == 0) {
				m = i + 1;
				break;
			}
		}
		// 2019 年 2 月 24 日 星期日 
		int timeDiff = buf[year][m][day] - buf[2019][2][24]; // 时间差可正可负
		cout << weekName[(timeDiff % 7 + 7) % 7] << endl;
	}
	return 0;
}
```

小结：

- 星期和月份的英文单词需牢记。
- 字符数组末尾有 `\0`，输入长度有限的字符串时优先考虑字符数组。
- 时间差可正可负，进行模运算前需处理。



### 1.5 进制转换

### 1.6 字符串处理



## 第2章 算法初步

### 2.1 排序

#### 2.1.1 冒泡排序

时间复杂度：$O(n^2)$
空间复杂度：$O(1)​$

```C++
// 对 a[0] ~ a[n] 进行排序
void bubbleSort(){
    for (int i = 0; i < n; i++) { // 循环次数比数组长度小 1
        for (int j = 0; j < n - i - 1; j++) {
			if (a[j] > a[j + 1]) { // 交换 a[j] 与 a[j+1]
				int t = a[j];
                a[j] = a[j + 1];
                a[j + 1] = t;
			}
        }
    }
}
```



#### 2.1.2 选择排序

时间复杂度：$O(n^2)$
空间复杂度：$O(1)​$

```C++
// 对 a[0] ~ a[n] 进行排序
void selectSort(){
    for(int i = 0; i < n; i++){ // 循环次数比数组长度小 1
        int k = i;
        for(int j = i; j <= n; j++){
            if(a[j] < a[k]) // 选出未排序区间中最小的元素，下标为 k
                k = j;
        }
        int temp = a[i]; // 交换 A[i] 与 A[k]
        a[i] = a[k];
        a[k] = temp;
    }
}
```



#### 2.1.3 插入排序

#### 2.1.4 双指针：归并排序

#### 2.1.5 双指针：快速排序

#### 2.1.6 排序与 sort 函数的应用



## 第3章 数学问题

### 3.1 简单数学



### 3.2 最大公约数与最小公倍数

#### 3.2.1 最大公约数：欧几里得算法 / 辗转相除法

- 非递归实现

```C++
int GCD(int a, int b){
    if(b)
        while((a %= b) && (b %= a));
    return a + b;
}
```

```C++
int GCD(int a, int b){
    while(b){
        int t = a % b;
        b = a;
        a = t;
    }
    return a;
}
```

- 递归实现

```C++
int GCD(int a, int b){
    return b ? GCD(b, a % b) : a;
}
```



#### 3.2.2 最小公倍数

```C++
int LCM(int a, int b){
    return a / GCD(a, b) * b; // 先除后乘避免溢出
}
```



### 3.3 分数四则运算

#### 3.3.1 分数表示与化简

- 分数的表示
  - 常用假分数的形式表示
  - 设分母为非负数；如果分数为负，令分子为负即可
  - 分子和分母没有除了1以外的公约数，即总是约分

```C++
struct Fraction { // 分数
    int up, down; // 分子，分母
}
```

- 分数的化简
  - 如果分母为负数，分子、分母都取相反数
  - 如果分子为0，令分母为1
  - 约分：求出分子**绝对值**与分母**绝对值**的最大公约数`d`，令分子分母同时除以`d`

```C++
Fraction reduction(Fraction result){
    if(result.down < 0){
        result.down = -result.down;
        result.up = -result.up;
    }
    if(result.up == 0)
        result.down = 1;
    else{
        int d = GCD(abs(result.up), abs(result.down));
        result.up /= d;
        result.down /= d;
    }
    return result;
}
```

#### 3.3.2 分数四则运算

- 分数的加法

```C++
Fraction add(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.down + f2.up * f1.down;
    result.down = f1.down * f2.down;
    return reduction(result);
}
```

- 分数的减法

```C++
Fraction minu(Fraction f){
    f.up = -f.up;
    return reduction(f);
}

Fraction minu(Fraction f1, Fraction f2){
    return add(f1, minu(f2));
}
```

- 分数的乘法

```C++
Fraction multi(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.up;
    result.down = f1.down * f2.down;
    return reduction(result);
}
```

- 分数的除法

```C++
Fraction divide(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.down;
    result.down = f1.down * f2.up;
    return reduction(result);
}
```



#### 3.3.3 分数的输出

- 输出分数前，进行**化简**。
- 如果分母为1，则该分数为**整数**，直接输出分子。
- 如果分子绝对值大于分母，则该分数为假分数，应以**带分数**的形式输出。
- 若以上均不满足，则分数是**真分数**，按原样输出即可。

```C++
void showResult(Fraction r) {
    r = reduction(r);
    if(r.down == 1) printf("%lld", r.up); // 整数
    else if(abs(r.up) > r.down) { // 假分数
        printf("%d %d/%d", r.up / r.down, abs(r.up) % r.down, r.down);
    }
    else {
        printf("%d/%d", r.up, r.down);
    }
}
```



### 3.4 素数

#### 3.4.1 素数的判断

素数判断，若 $n​$ 为素数返回`true`，非素数返回`false`。

- 注意，小于等于1的整数非素数。
- 只需要循环判断小于等于 $\sqrt{n}$ 的整数是否为 $n$ 的因子。

```C++
bool isPrime(int n) {
    if(n <= 1) return false;
    for(int i = 2; i * i <= n; i++) { // 或 i <= (int)sqrt(n + 0.5)
        if(n % i == 0) return false;
    }
    return true;
}
```



#### 3.4.2 素数表的获取

构建素数表 `comp`，`comp[i]`为假表示`i`为素数，`comp[i]`为真表示`i`为合数。

```C++
int m = sqrt(n + 0.5);
bool comp[n + 5];
memset(comp, false, sizeof(comp));

for(int i = 2; i <= m; i++) {
    if(!comp[i]) {
        for(int j = i * i; j <= n; j += i) {
            comp[j] = true;
        }
    }
}
```



## 第4章 C++ 标准模版库

## 第5章 数据结构：栈、队列与链表

## 第6章 搜索

### 6.1 枚举

### 6.2 广度优先搜索 BFS

BFS 中常用的数据结构是队列，常用技巧是剪枝。

在此列举并尝试总结经典题目。



### 6.3 递归

### 6.4 深度优先搜索 DFS

在此列举并尝试总结经典题目。

- （Easy）第九届蓝桥杯省赛C++组A组 第8题 全球变暖



## 第7章 树算法

参考 LeetCode-探索 二叉树 卡片。

### 7.1 树与二叉树

### 7.2 二叉树的遍历

### 7.3 树的遍历

### 7.4 二叉搜索树 BST

### 7.5 平衡二叉树 AVL

### 7.6 并查集

### 7.7 堆

### 7.8 哈夫曼树

## 第8章 图算法

### 8.1 图的存储

图的表示形式通常是邻接矩阵或邻接表。

- 邻接表表示图

```C++
struct Node {
    int v; // 边的终点编号
    int w; // 边权
    Node(int v, int w): v(v), w(w) {} // 构造函数
}
vector<Node> adj[N];
```

### 8.2 图的遍历

#### 8.2.1 图的深度优先遍历

#### 8.2.2 图的广度优先遍历



### 8.3 最短路径

#### 8.3.1 Dijkstra 算法

Dijkstra 算法解决的是单源最短路问题，边上的权重需要满足非负。

原算法时间复杂度：$O(V^2 + E)$
使用堆优化后的时间复杂度：$O(V\log{V} + E)$

Dijkstra 算法关键有两部分，相辅相成：

- 找到尚未访问的点：结合标记数组，查找尚未访问且已知距离的点中，距离起点最近的点。
- 更新更短的距离：在找到一个尚未遍历的点u时，以u为中介点更新起点到u的邻接点v的距离。



- 邻接矩阵的实现：

```C++
#include <iostream>
#include <algorithm>

using namespace std;
#define MAXV 1010
#define INF 0x3f3f3f3f

int n, m, s; // 顶点个数，边数，起点编号 
int G[MAXV][MAXV]; // MAXV为最大顶点数
int d[MAXV]; // 起点到达各点的最短路径长度
bool vis[MAXV] = {false}; // 表示是否访问的数组

void Dijkstra(int s) { // s为起点
    fill(d, d + MAXV, INF); // 相当于C语言的memset
    d[s] = 0; // 起点到达自身的距离为0，不要把起点标记为已访问
    for(int i = 0; i < n; i++) { // 循环次数为顶点的数量
        int u = -1, MIN = INF; // 找到u使得d[u]最小，MIN存放该最小的d[u]
        for(int j = 0; j < n; j++) {
            if(vis[j] == false && d[j] < MIN) {
                u = j;
                MIN = d[j];
            }
        }
        // 找不到小于INF的d[i]，说明剩下的顶点和起点s不连通
        if(u == -1) return;
        vis[u] = true; // 标记u为已访问
        for(int v = 0; v < n; v++) {
            // 如果v未访问 且 u能到达v 且 以u为中介点可以使d[v]更优
            if(vis[v] == false && G[u][v] != INF && d[u] + G[u][v] < d[v]) {
                d[v] = d[u] + G[u][v];
            }
        }
    }
}

int main() {
    int u, v, w;
    cin >> n >> m >> s; // 顶点个数，边数，起点编号
    fill(G[0], G[0] + MAXV * MAXV, INF); // 初始化图G
    for(int i = 0; i < m; i++) {
        cin >> u >> v >> w;
        G[u][v] = w;
    }
    Dijkstra(s); // Dijkstra 算法入口
    for (int i = 0; i < n; i++) {
        cout << d[i] << " "; // 输出起点到所有顶点的最短距离
    }
    return 0;
}
```

- 使用堆优化的邻接矩阵实现：

```C++
#include <iostream>
#include <algorithm>
#include <queue> 

using namespace std;
#define MAXV 1010
#define INF 0x3f3f3f3f

int n, m, s; // 顶点个数，边数，起点编号 
int G[MAXV][MAXV]; // MAXV为最大顶点数
int d[MAXV]; // 起点到达各点的最短路径长度
bool vis[MAXV] = {false}; // 表示是否访问的数组

void Dijkstra(int s) { // s为起点
	priority_queue <int, vector<int>, greater<int> > que;
	que.push(s);
	fill(d, d + MAXV, INF); // 相当于C语言的memset
	d[s] = 0;
	while(!que.empty()) {
		int u = que.top();
		que.pop();
	    
		vis[u] = true; // 标记u为已访问
	    for(int v = 0; v < n; v++) {
	    	// 如果v未访问 且 u能到达v 且 以u为中介点可以使d[v]更优
	        if(vis[v] == false && G[u][v] != INF && d[u] + G[u][v] < d[v]) {
	           d[v] = d[u] + G[u][v];
	           que.push(v);
	        }
	    }
	}
}

int main() {
    int u, v, w;
    cin >> n >> m >> s; // 顶点个数，边数，起点编号
    fill(G[0], G[0] + MAXV * MAXV, INF); // 初始化图G
    for(int i = 0; i < m; i++) {
        cin >> u >> v >> w;
        G[u][v] = w;
    }
    Dijkstra(s); // Dijkstra 算法入口
    for (int i = 0; i < n; i++) {
        cout << d[i] << " "; // 输出起点到所有顶点的最短距离
    }
    return 0;
}
```



### 8.3.2 Bellman-Ford 算法和 SPFA 算法



### 8.3.3 Floyd 算法

Floyd 算法解决的是全源最短路问题。由于时间复杂度的限制，决定了顶点数的限制约在 200 以内。使用邻接矩阵实现非常合适且方便。

时间复杂度：$O(n^3)$

Floyd 算法为了计算全源最短路，付出了非常大的代价，实质上是暴力枚举图中任意两点之间任何可能的边。与 Dijkstra 算法类似，采用中介点更新路径。

- 邻接矩阵的实现：

```C++
int dis[MAXV][MAXV]; // dis[i][j] 表示顶点i到顶点j的距离

void Floyd() {
    for(int k = 0; k < n; k++) {
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(dis[k][i] != INF && dis[k][j] != INF && dis[i][k] + dis[k][j] < dis[i][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                }
            }
        }
    }
}
```



## 第9章 动态规划

- 【Medium】LeetCode 264. Ugly Number II， 第九届蓝桥杯省赛C++组A组 第4题



## 第10章 字符串



## 第11章 专题扩展

### 11.1 分块思想



### 11.2 树状数组
