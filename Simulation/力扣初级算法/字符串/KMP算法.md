# 字符串匹配的 KMP 算法

## 字符串匹配的暴力方法

复杂的算法都由朴素的算法演变而来。对于字符串匹配，最简单的方法是两重循环逐个比对，匹配失败时模式串相比文本串后移一位，从模式串的第一位重新匹配。

时间复杂度 $O(n * m)$，其中 $n$ 是文本串的长度，$m$ 是模式串的长度。

## KMP 算法

### 从记忆到预知

KMP 算法的时间复杂度是 $O(n)$.

当失配发生时，实际上我们已经获知已经匹配部分的文本串的全部信息。
充分利用已经匹配的信息，在失配前已经匹配的子串中找到最长公共前后缀，可以优化算法。
KMP 算法相比暴力算法的优势，有两个方面：

1. 大幅度地滑动模式串，而不是每次只移动1位
2. 避免大量无意义的比对

如何确定模式串具体跳转的位置呢？

### 查询表

模式串跳转的位置 `next` 可以说与文本串无关，而只与模式串有关。因为文本串和模式串在失配前已经匹配的部分，信息是一致的。通过模式串应当能直接生成查询表 `next`。

模式串的自匹配使得快速右移成为可能。在具体的匹配中，查询表应当只与模式串已经匹配的前缀有关，最多有 $m$ 种情况。其中，$m$ 是模式串的长度。

KMP 主算法：

```c++
int match(char* p, char* t) {
    int* next = buildNext(p);  		// 构造 next 表
    int n = strlen(t), i = 0;  		// 文本串指针
    int m = strlen(p), j = 0;  		// 模式串指针
    while(j < m && i < n) {	   		// 从左向右，逐个比对字符
        if(j < 0 || t[i] == t[j]) { // 如果匹配
            i++;
            j++;
        } else {					// p 右移，t 不回退
            j = next[j];
        }
    }
    delete[] next;					// 释放 next 表
    return i - j;
}
```



### next 快速移动

通过观察可以发现，快速右移需要模式串具有公共前后缀。

而这样的快速右移会不会造成匹配过程中的遗漏？如果 `next` 数组存储的是最长自匹配的信息，实际上可以避免回退。也就是针对每一种失配情况，`next` 数组给出的跳转方案是唯一的，即最长自匹配的结果。

避免回退隐含的意思是，对于 `next` 给出的跳转位置之前的位置，是没有意义去对齐的。

`next` 数组中可以使用哨兵，作为假想的元素：

- 简化代码
- 统一理解

### 构造 next 递推

`next` 表构造过程与 KMP 主算法的过程在本质上是相同的。

如果 `P[j] == P[next[j]]`，`next[j + 1] = next[j] + 1`.

如果 `P[j] != P[next[j]]`，则 `next[j + 1]` 的候选者依次是：

- `1 + next[j]`
- `1 + next[next[j]]`
- `1 + next[next[next[j]]]`

这个序列严格递减，并且必收敛于 `1 + next[0] = 0`. 这个递推过程，就是模式串的自匹配过程，只需在 KMP 主程序的框架上略作修改。

```c++
int* buildNext(char *p) {
    int m = strlen(p), j = 0;
    int *next = new int[m];
    
    int t = next[0] = -1; 			// 模式串指针，p[-1] 通配符
    while(j < m - 1) {
        if(t < 0 || p[j] == p[t])	// 匹配
            next[++j] = ++t;
        else						// 失配
            t = next[t];
    }
    return next;
}
```

