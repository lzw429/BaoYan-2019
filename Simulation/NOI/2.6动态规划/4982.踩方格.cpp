//
// Created by Yiheng Shu on 19-5-9.
//

/*
 * 4982:踩方格
查看 提交 统计 提问
总时间限制: 1000ms 内存限制: 65536kB
描述
有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设：
a.    每走一步时，只能从当前方格移动一格，走到某个相邻的方格上；
b.    走过的格子立即塌陷无法再走第二次；
c.    只能向北、东、西三个方向走；
请问：如果允许在方格矩阵上走n步，共有多少种不同的方案。2种走法只要有一步不一样，即被认为是不同的方案。

输入
允许在方格上行走的步数n(n <= 20)
输出
计算出的方案数量
样例输入
2
样例输出
7
 */

#include <iostream>
#include <set>
#include <queue>

using namespace std;

const int maxn = 25;
int dp[maxn]; // dp[i] 表示走i步的方案数
int ans;

int main() {
    int n;
    cin >> n;

    // 动态规划方程 dp[i] = 2 * dp[i - 1] + dp[i - 2]
    // 第i步的方案数 等于 2 * 第i-1步是左右移动的方案数 加 3 * 第i-1步是向上移动的方案数
    // 因为 1)第i-1步向左(右)移动后，第i步可以向右(左)移动和向上移动
    //     2)第i-1步向上移动后，第i步可以向三个方向移动
    // 该式等于 2 * 第i-1步所有方案数 加 1 * 第i-1步是向上移动的方案数
    // 其中，第i-1步是向上移动的方案数 等于 第i-2步的所有方案数，无论第i-2步的方向如何
    dp[1] = 3;
    dp[2] = 7;
    for (int i = 3; i < maxn; i++) {
        dp[i] = 2 * dp[i - 1] + dp[i - 2];
    }
    cout << dp[n] << endl;
    return 0;
}
