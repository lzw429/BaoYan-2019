/*
 * 8780:拦截导弹
查看 提交 统计 提问
总时间限制: 1000ms 内存限制: 65536kB
描述
某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹。

输入
第一行是一个整数N（不超过15），表示导弹数。
第二行包含N个整数，为导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数）。
输出
一个整数，表示最多能拦截的导弹数。
样例输入
8
389 207 155 300 299 170 158 65
样例输出
6
 */


// 本题是求最大非递增子序列的典例
// 样例中的最大非递增子序列是 389 300 299 170 158 65，长度为 6
// 注意动态规划数组的意义，答案不一定是 dp[n - 1]

#include <iostream>

using namespace std;

const int maxn = 20;
int nums[maxn];
int dp[maxn]; // dp[i] 表示 nums[0...i] 中包含 nums[i] 的最大非递增子序列的长度

/**
 * 初始化
 *
 * 将动态规划数组的所有元素初始化为1，任何非空序列的最大非递增子序列长度至少为1
 */
void init() {
    for (int i = 0; i < maxn; i++) {
        dp[i] = 1;
    }
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    int ans = 1;
    init(); // 注意动态规划数组的初始化
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] >= nums[i]) { // 注意是大于等于，而不是大于
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        ans = max(ans, dp[i]);
    }

    cout << ans << endl;
    // 注意，答案不一定是 dp[n - 1]
    return 0;
}
